# Rabbitmq cheatsheet

### Learn
→ rabbitmq.com/documentation
### Download
→ rabbitmq.com/download
### Get started
→ rabbitmq.com/getstarted

# Оглавление
<!-- TOC -->
- [Понятия](#Понятия)
  - [Обменник](#Обменник)
    - [Default_exchange](#Default_exchange)
    - [Тип_обменика](#Тип_обменика)
    - [Создание_обменника](#Создание_обменника)
    - [Связывание_обменника](Связывание_обменника)
    - [Очередь](#Очередь)
    - [Создание_очереди](#Создание_очереди)
    - [Отправитель](#Отправитель)
    - [Отправка_сообщения](#Отправка_сообщения)
    - [Получатель](#Получатель)
<!-- /TOC -->

Общие упрощенные понятия. Возможно существуют способы задать другое поведение нежели данное упощенное.
## Понятия
* producer - отправитель, программный код, который отправляет сообщение.
* consumer - получатель, программный код, который должен получить сообшение.
* exchange - обменник, функционал RabbitMQ, получает сообщение с заданными параметрами от отправителя и:
  * может сбросить(удалить) сообщение или вернуть отправителю (зависит от атрибутов сообщения),
  * может отправить сообщение в очередь, 
  * может отправить сообщение в несколько очередей (сообщение будет скопировано для каждой очереди)
* queue - очередь, функционал RabbitMQ, хранит все сообщения и раздает их получателям.
* message - сообщение, содержит атрибуты необходимые RabbitMQ, а также данные для передачи от отправителя к получателю
* binding - связывание очереди и обменника. Обменник может отправить сообщения только в те очереди которые с ним связаны. 
* routingKey - ключ маршрутизации (может не использоваться), используется обменником для маршрутизации (выбора очереди(ей)) сообщений.
  * используется при связывании очереди с обменником
  * содержится в атрибуте сообщения
  при совпадении этих ключей сообщение будет отправлено в очередь

## Обменник

### Default_exchange
RabbitMQ всегда создает безымянный обменник типа direct. 
На этот обменник по умолчанию завязаны все очереди, где routingKey равен имени очереди.
Отправка сообщения напрямую в очередь на самом деле это отправка сообщения безымянному обменнику с routingKey нужной очереди.
Как итог это выглядит и работает как отправка сообщения напрямую в очередь, но сообщения всегда отправляются через обменник.

### Тип_обменика (один из четырех вариантов)
  1. direct - прямая отправка в очередь, используется routingKey. Сообщение с каким-то routingKey будет отправленно обменником
  в очередь связанную с этим обменником с тем же routingKey, иначе сброшено(удалено).
  2. fanout - routingKey игнорируется, сообщения будут отправлены во все очереди связанные с обменником
  3. topic - похож на direct, сообщения отправляются с routingKey, но очереди связываются с обменником по шаблонной строке, сообщение попадет в те очереди с шаблонами которых совпадает routingKey
  4. headers - (todo)

### Создание_обменника
```javascript
assertExchange(exchange_name, type, [options])
```
 * указать имя обменника
 * тип обменника
 * перечень аргументов
  * durable (bool) - сохранять и восстанавливать после рестарта RabbitMQ
  * autoDelete (bool) - удалится после того как все очереди отключатся
  * (todo)

### Связывание_обменника
```javascript
bindQueue(queue_name, exhange_name, pattern, [args])
```
Необходимо указать:
 * имя очереди
 * имя обменника
 * шаблон или routingKey (зависит от типа обменника)

## Очередь
Перед использованием должны быть созданы. 
Повторное создание с теми же аргументами не создаст ошибки и не создаст еще одну очередь.
Повторное создание с другими аргументами создаст ошибку.

### Создание_очереди
```javascript
assertQueue([queue, [options]])
```
* имя очереди (опционально), RabbitMQ сгенерирует имя при необходимости 
* опции
  * exclusive - используется только данным подключением, будет удалено после закрытия подключения
  * durable - сохранение после рестарта
  * autoDelete - удалится если кол-во получетелей станет ноль
  * maxPriority - очередь станет поддерживать приоритетные сообщения с приоритетом от 0 до maxPriority, чем выше число тем приоритетнее
  * (todo)

## Отправитель
Программа не входящая в состав RabbitMQ, отправляет сообщения.

### Отправка_сообщения (публикация)
```javascript
publish(exchange_name, routingKey, content, [options])
```
* имя обменника
* ключ маршрутизации
* содержимое сообщения
* опции
  * expiration - строка в мс, время через которое сообщение будет удалено из очереди
  * priority - приоритет, для приоритетных очередей
  *  persistent - сохранение сообщения при перезагрузки
  *  mandatory - если true, то сообщение будет возвращено отправителю в случае когда не нашлось очереди для отправки
  *  (todo)

## Получатель
Программа не входящая в состав RabbitMQ, получает сообщения.

### Прием сообщения
```javascript
consume(queue_name, function(msg) {...}, [options])
```
* имя очереди
* функция
* опции
  * noAck - сообщение подверждается при получении автоматически и будет удалено из очереди независимо от как обработано сообщение получателем
  * exclusive - эксклюзивное подключение
  * priority - приоритет получателя

Сервер вернет consumerTag, необходимый для отмены приема сообщений в будущем. 
Null вернется для отмененных сообщений.

### Ограничение на прием
```javascript
prefetch(count, [global])
```
Количество не подтвержденных сообщений которых может получить получатель.

## rabbitmqctl

### vhost

* rabbitmqctl add_vhost [vhost_name]

* rabbitmqctl delete_vhost [vhost_name]

* rabbitmqctl list_vhost [vhost_name]

### permissions

* rabbitmqctl set_permissions [-p \<vhost\>] \<user\> \<conf\> \<write\> \<read\>

  e.g: rabbitmqctl set_permission -p sycamore xiaochen ".\*" ".\*" ".\*"

### stop

* rabbitmqctl stop [-n \<node\>]

## service rabbitmq-server

* service rabbitmq-server start

  \# start the service

* service rabbitmq-server stop

  \# stop the service

* service rabbitmq-server restart

  \# restart the service

* service rabbitmq-server status

  \# check the status
